{
  "structures": [
    {
      "name": "Array",
      "content": "# Array\n  \n​\n## Introduction\n  \n​\nAn array is a collection of elements identified by index or key values. It's one of the most fundamental data structures in computer science, where each element can be accessed directly by its index. Imagine a row of numbered lockers, where each locker can hold a value and you can access any locker directly by knowing its number.  \n​\n  \n​\n## Use Cases\n  \n​\n- Arrays are highly useful in situations where the data to be stored is of fixed size or the size is well known in advance.  \n​\n- They are commonly used when you need to keep track of a list of items, and the order in which they are stored matters.  \n​\n- Not suitable for scenarios where the size of data is dynamic or unknown in advance, a Linked List or Dynamic Array might be a better choice in such cases.  \n​\n  \n​\n## Operations\n  \n​\n- **Access:** *O(1)* - Accessing an element in an array is a constant time operation as you can access any element directly by its index.  \n​\n- **Insertion:** *O(n)* - Insertion in an array requires shifting of elements, hence it takes linear time.  \n​\n- **Deletion:** *O(n)* - Similar to insertion, deletion also requires shifting of elements.  \n​\n- **Search:** *O(n)* - In the worst case, you may have to traverse the entire array to find an element.  \n​\n  \n​\n## Implementation\n  \n​\n### Access: *O(1)*\n  \n​\n```plaintext  \n​\nfunction accessArray(array, index):  \n​\n    return array[index]  \n​\n```  \n​\n  \n​\nAccessing an element in an array is straightforward. You simply specify the index of the element you want to access.  \n​\n  \n​\n### Insertion: *O(n)*\n  \n​\n```plaintext  \n​\nfunction insertArray(array, index, value):  \n​\n    // Shift all elements to the right of the index one position to the right  \n​\n    for i from array.length - 1 to index:  \n​\n        array[i + 1] = array[i]  \n​\n    // Place the new value at the specified index  \n​\n    array[index] = value  \n​\n```  \n​\n  \n​\nInsertion in an array involves two steps. First, all elements to the right of the specified index are shifted one position to the right to make room for the new element. Then, the new element is placed at the specified index.  \n​\n  \n​\n### Deletion: *O(n)*\n  \n​\n```plaintext  \n​\nfunction deleteArray(array, index):  \n​\n    // Shift all elements to the right of the index one position to the left  \n​\n    for i from index to array.length - 2:  \n​\n        array[i] = array[i + 1]  \n​\n    // Decrease the length of the array by 1  \n​\n    array.length = array.length - 1  \n​\n```  \n​\n  \n​\nDeletion in an array also involves shifting of elements. All elements to the right of the specified index are shifted one position to the left to fill the gap left by the deleted element. The length of the array is then decreased by 1.  \n​\n  \n​\n### Search: *O(n)*\n  \n​\n```plaintext  \n​\nfunction searchArray(array, value):  \n​\n    for i from 0 to array.length - 1:  \n​\n        if array[i] == value:  \n​\n            return i  // Return the index of the found element  \n​\n    return -1  // Return -1 if the element is not found  \n​\n```  \n​\n  \n​\nSearching in an array involves traversing the array from the beginning to the end and checking each element to see if it matches the desired value.  \n​\n  \n​\n## Problems\n  \n​\n### LeetCode\n  \n​\n- **[Permutations](https://leetcode.com/problems/permutations/)**: Given an array `nums` of distinct integers, return all the possible permutations.  \n​\n  \n​\n- **[Sort an Array](https://leetcode.com/problems/sort-an-array/)**: Given an array of integers `nums`, sort the array in ascending order without using any built-in functions.  \n​\n  \n​\n- **[Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)**: Find the subarray with the largest sum from given integer array `nums`.  \n​\n  \n​\n- **[3Sum](https://leetcode.com/problems/3sum/)**: Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j, i != k, and j != k`.  \n​\n  \n​\n- **[Majority Element](https://leetcode.com/problems/majority-element/)**: Given an array `nums` of size `n`, return the majority element which is the element that appears more than ⌊n / 2⌋ times.  \n​\n  \n​\n### HackerRank\n  \n​\n- **[Arrays - DS](https://www.hackerrank.com/challenges/arrays-ds/problem)**: Reverse an array of integers.  \n​\n  \n​\n- **[Simple Array Sum](https://www.hackerrank.com/challenges/simple-array-sum/problem)**: Given an array of integers, find the sum of its elements.  \n​\n  \n​\n- **[Larry's Array](https://www.hackerrank.com/challenges/larrys-array/problem)**: Given a permutation of a sequence of natural numbers as an array, determine whether the array can be sorted using a specific operation.  \n​\n  \n​\n- **[Circular Array Rotation](https://www.hackerrank.com/challenges/circular-array-rotation/problem)**: Perform a number of right circular rotations on an array and return the values of the elements at the given indices.  \n​\n  \n​\nThese problems will help you grasp different aspects of array manipulations and are great for interview preparation.  \n​",
      "id": 1
    },
    {
      "name": "Linked List",
      "content": "# Linked List\n  \n​\n## Introduction\n  \n​\n  \n​\nA Linked List is a linear data structure where elements are stored in nodes, and each node points to the next node in the list, forming a chain-like structure. Unlike arrays, linked lists don’t have indexes for element access and are not stored in contiguous memory locations. Picture a chain where each link represents a value, and it holds a reference to the next link in the chain.  \n​\n  \n​\n## Use Cases\n  \n​\n- Linked Lists are suitable when you have an unknown number of data elements or when you need to insert and delete elements frequently.  \n​\n- They are often used in scenarios where sequential access is required rather than random access.  \n​\n- When memory allocation is a concern, Linked Lists are preferable as they are dynamically sized. However, for random access operations, arrays or other data structures might be a better choice due to the constant time access they offer.  \n​\n  \n​\n## Operations\n  \n​\n- **Access:** *O(n)* - Accessing an element requires traversing the list from the head to the desired element.  \n​\n- **Insertion:** *O(1)* - Inserting a new node is a constant time operation if done at the head or tail.  \n​\n- **Deletion:** *O(1)* - Deleting a node is a constant time operation if done at the head or tail.  \n​\n- **Search:** *O(n)* - Searching for a value requires traversing the list until the value is found.  \n​\n  \n​\n## Implementation\n  \n​\n### Access: *O(n)*\n  \n​\n```plaintext  \n​\nfunction accessNode(head, index):  \n​\n    current = head  \n​\n    count = 0  \n​\n    while current is not null:  \n​\n        if count == index:  \n​\n            return current.value  \n​\n        count += 1  \n​\n        current = current.next  \n​\n    return null  // Index out of bounds  \n​\n```  \n​\n  \n​\nAccessing a node in a linked list requires traversing the list from the head node to the desired index. This is done by starting at the head node and following the next pointers from one node to the next until the desired index is reached or the end of the list is encountered.  \n​\n  \n​\n### Insertion: *O(1)*\n  \n​\n```plaintext  \n​\nfunction insertNode(head, value):  \n​\n    newNode = new Node(value)  \n​\n    newNode.next = head  \n​\n    head = newNode  \n​\n```  \n​\n  \n​\nInsertion at the head of a linked list is a constant time operation. A new node is created with the desired value, its next pointer is set to the current head node, and then the head pointer is updated to point to the new node.  \n​\n  \n​\n### Deletion: *O(1)*\n  \n​\n```plaintext  \n​\nfunction deleteNode(head):  \n​\n    if head is not null:  \n​\n        temp = head  \n​\n        head = head.next  \n​\n        temp.next = null  // Optional: Break the link to the rest of the list  \n​\n```  \n​\n  \n​\nDeleting the head node of a linked list is also a constant time operation. The head pointer is updated to point to the second node in the list, and the next pointer of the original head node is optionally set to null to break the link to the rest of the list.  \n​\n  \n​\n### Search: *O(n)*\n  \n​\n```plaintext  \n​\nfunction searchNode(head, value):  \n​\n    current = head  \n​\n    while current is not null:  \n​\n        if current.value == value:  \n​\n            return true  \n​\n        current = current.next  \n​\n    return false  \n​\n```  \n​\n  \n​\nSearching in a linked list requires traversing the list from the head node to the end, checking each node to see if its value matches the desired value.  \n​\n  \n​\n## Problems\n  \n​\nBelow are various problems from different platforms that test different aspects of Linked List manipulations and understanding:  \n​\n  \n​\n### LeetCode\n  \n​\n- [**Linked List Cycle**:](https://leetcode.com/problems/linked-list-cycle/) Determine if a linked list has a cycle in it by identifying if some node can be reached again by continuously following the next pointer.  \n​\n  \n​\n- [**Remove Linked List Elements**:](https://leetcode.com/problems/remove-linked-list-elements/) Given the head of a linked list and an integer value, remove all the nodes of the linked list that have this value, and return the new head.  \n​\n  \n​\n- [**Middle of the Linked List**:](https://leetcode.com/problems/middle-of-the-linked-list/) Return the middle node of a linked list, and if there are two middle nodes, return the second middle node.  \n​\n  \n​\n- [**Design Linked List**:](https://leetcode.com/problems/design-linked-list/) Design an implementation of the linked list, with the option to use a singly or doubly linked list.  \n​\n  \n​\n- [**Reverse Linked List**:](https://leetcode.com/problems/reverse-linked-list/) Reverse a linked list and return the reversed list.  \n​\n  \n​\n### HackerRank\n  \n​\n- [**Insert a Node at a Specific Position in a Linked List**:](https://www.hackerrank.com/domains/data-structures/linked-lists#:~:text=Easy%20Problem%20Solving%20,04) Insert a node at a specific position in a linked list.  \n​\n  \n​\n- [**Inserting a Node Into a Sorted Doubly Linked List**:](https://www.hackerrank.com/interview/interview-preparation-kit/linked-lists/challenges#:~:text=Easy%20Problem%20Solving%20,Reverse%20a%20doubly%20linked%20list) Create a node with a given value and insert it into a sorted doubly-linked list.  \n​\n  \n​\n- [**Print the Elements of a Linked List**:](https://www.hackerrank.com/challenges/print-the-elements-of-a-linked-list/problem#:~:text=This%20is%20an%20to%20practice,function%20in%20the%20editor%20below) Practice traversing a linked list by printing each node's element.  \n​\n  \n​\n- [**Merge Two Sorted Linked Lists**:](https://www.hackerrank.com/challenges/merge-two-sorted-linked-lists/problem#:~:text=The%20second%20linked%20list%20is%3A,a%20single%2C%20sorted%20linked%20list) Given the heads of two sorted linked lists, change their links to get a single, sorted linked list.  \n​\n  \n​\n- [**Find Merge Point of Two Lists**:](https://www.hackerrank.com/challenges/find-the-merge-point-of-two-joined-linked-lists/problem) Given pointers to the head nodes of linked lists that merge together at some point, find the node where the two lists merge.  \n​\n  \n​\nThese problems cover a range of topics including list traversal, node insertion, list reversal, and detecting cycles, providing a comprehensive understanding of handling linked lists in algorithmic problems.  \n​",
      "id": 2
    },
    {
      "name": "Stack",
      "content": "# Stack\n  \n​\n## Introduction\n  \n​\n  \n​\nA Stack is a linear data structure that follows the LIFO (Last In First Out) principle, where the last element added is the first one to be removed. It is akin to a stack of plates, where you can only add a new plate on top and remove the plate from the top.  \n​\n  \n​\n## Use Cases\n  \n​\n- Stacks are used in scenarios where data needs to be processed in a LIFO manner.  \n​\n- Common use cases include expression evaluation, syntax parsing, backtracking algorithms, and maintaining a history of actions for undo operations.  \n​\n- They might not be suitable for scenarios where data needs to be accessed randomly or in a FIFO (First In First Out) manner, where queues would be a better choice.  \n​\n  \n​\n## Operations\n  \n​\n- **Push:** *O(1)* - Adds a new element on top of the stack.  \n​\n- **Pop:** *O(1)* - Removes the top element from the stack.  \n​\n- **Peek:** *O(1)* - Returns the top element without removing it from the stack.  \n​\n- **IsEmpty:** *O(1)* - Checks if the stack is empty.  \n​\n  \n​\n## Implementation\n  \n​\n### Push: *O(1)*\n  \n​\n```plaintext  \n​\nfunction push(stack, value):  \n​\n    stack.top = stack.top + 1  // Increment top pointer  \n​\n    stack[stack.top] = value   // Add the new value at the top position  \n​\n```  \n​\n  \n​\nPush operation involves incrementing the top pointer and placing the new value at the top position of the stack. It's a constant time operation as it requires a fixed number of steps.  \n​\n  \n​\n### Pop: *O(1)*\n  \n​\n```plaintext  \n​\nfunction pop(stack):  \n​\n    if stack.top == -1:  // Check if stack is empty  \n​\n        return \"Underflow Error\"  \n​\n    value = stack[stack.top]  // Get the top value  \n​\n    stack.top = stack.top - 1  // Decrement top pointer  \n​\n    return value  \n​\n```  \n​\n  \n​\nPop operation involves checking if the stack is empty, getting the top value, and decrementing the top pointer. It also executes in constant time.  \n​\n  \n​\n### Peek: *O(1)*\n  \n​\n```plaintext  \n​\nfunction peek(stack):  \n​\n    if stack.top == -1:  // Check if stack is empty  \n​\n        return \"Stack is Empty\"  \n​\n    return stack[stack.top]  // Return the top value without popping it  \n​\n```  \n​\n  \n​\nPeek operation returns the top value of the stack without popping it. It's a constant time operation as it only requires accessing the top value.  \n​\n  \n​\n### IsEmpty: *O(1)*\n  \n​\n```plaintext  \n​\nfunction isEmpty(stack):  \n​\n    return stack.top == -1  // Return true if top pointer is -1, indicating an empty stack  \n​\n```  \n​\n  \n​\nIsEmpty operation checks if the stack is empty by comparing the top pointer to -1. It's a constant time operation as it only requires a single comparison.  \n​\n  \n​\n## Problems\n  \n​\nBelow are various problems from different platforms that test different aspects of Stack manipulations and understanding:  \n​\n  \n​\n### LeetCode\n  \n​\n- **[Min Stack](https://leetcode.com/problems/min-stack)**: Implement a stack that supports push, pop, top, and retrieving the minimum element in constant time.  \n​\n  \n​\n- **[Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues)**: Implement a stack using two queues, ensuring all the standard stack operations are supported.  \n​\n  \n​\n- **[Build an Array With Stack Operations](https://leetcode.com/problems/build-an-array-with-stack-operations)**: Given a target array and a number n, use stack operations to build the target array with numbers from 1 to n.  \n​\n  \n​\n- **[Validate Stack Sequences](https://leetcode.com/problems/validate-stack-sequences)**: Determine if a given pushed and popped sequence could have been the result of a series of push and pop operations on an initially empty stack.  \n​\n  \n​\n- **[Maximum Frequency Stack](https://leetcode.com/problems/maximum-frequency-stack)**: Design a stack that supports push, pop, and retrieving the element with maximum frequency with ties broken by recency.  \n​\n  \n​\n### HackerRank\n  \n​\n- **[Balanced Brackets](https://www.hackerrank.com/challenges/balanced-brackets)**: Given a sequence of brackets, determine if it is balanced.  \n​\n  \n​\n- **[Equal Stacks](https://www.hackerrank.com/challenges/equal-stacks)**: Given three stacks of cylinders, find the maximum possible height of equal stacks by removing cylinders from the top of the stacks.  \n​\n  \n​\n- **[Poisonous Plants](https://www.hackerrank.com/challenges/poisonous-plants)**: In a garden, some plants are poisonous. Plants are arranged in a row and each day, any plant that is shorter than its adjacent left plant dies. Determine the number of days after which no more plants die.  \n​\n  \n​\n- **[Piling Up!](https://www.hackerrank.com/challenges/piling-up)**: There is a row of colored cubes, and you must create a new vertical pile of cubes such that if cube A is on top of cube B, then the side length of cube B is greater than or equal to the side length of cube A.  \n​\n  \n​\nThese problems cover a range of topics including stack implementation, bracket balancing, and operations on stacks.  \n​",
      "id": 3
    },
    {
      "name": "Queue",
      "content": "# Queue\n  \n​\n## Introduction\n  \n​\n  \n​\nA Queue is a linear data structure that follows the FIFO (First In First Out) principle, where the first element added is the first one to be removed. It resembles a real-world queue or line where people enter from the back and leave from the front.  \n​\n  \n​\n## Use Cases\n  \n​\n- Queues are used in scenarios where data needs to be processed in a FIFO manner.  \n​\n- Common use cases include scheduling tasks, handling requests in web servers, and order processing.  \n​\n- They may not be suitable for scenarios where data needs to be accessed or processed out of order; stacks or other data structures might be a better choice in such cases.  \n​\n  \n​\n## Operations\n  \n​\n- **Enqueue:** *O(1)* - Adds a new element at the end of the queue.  \n​\n- **Dequeue:** *O(1)* - Removes the element from the front of the queue.  \n​\n- **Peek:** *O(1)* - Returns the front element without removing it from the queue.  \n​\n- **IsEmpty:** *O(1)* - Checks if the queue is empty.  \n​\n  \n​\n## Implementation\n  \n​\n### Enqueue: *O(1)*\n  \n​\n```plaintext  \n​\nfunction enqueue(queue, value):  \n​\n    queue.rear = queue.rear + 1  // Increment rear pointer  \n​\n    queue[queue.rear] = value   // Add the new value at the rear  \n​\n```  \n​\n  \n​\nEnqueue operation involves incrementing the rear pointer and placing the new value at the rear position of the queue. It's a constant time operation as it requires a fixed number of steps.  \n​\n  \n​\n### Dequeue: *O(1)*\n  \n​\n```plaintext  \n​\nfunction dequeue(queue):  \n​\n    if queue.front > queue.rear:  // Check if queue is empty  \n​\n        return \"Underflow Error\"  \n​\n    value = queue[queue.front]  // Get the front value  \n​\n    queue.front = queue.front + 1  // Increment front pointer  \n​\n    return value  \n​\n```  \n​\n  \n​\nDequeue operation involves checking if the queue is empty, getting the front value, and incrementing the front pointer. It also executes in constant time.  \n​\n  \n​\n### Peek: *O(1)*\n  \n​\n```plaintext  \n​\nfunction peek(queue):  \n​\n    if queue.front > queue.rear:  // Check if queue is empty  \n​\n        return \"Queue is Empty\"  \n​\n    return queue[queue.front]  // Return the front value without dequeuing it  \n​\n```  \n​\n  \n​\nPeek operation returns the front value of the queue without dequeuing it. It's a constant time operation as it only requires accessing the front value.  \n​\n  \n​\n### IsEmpty: *O(1)*\n  \n​\n```plaintext  \n​\nfunction isEmpty(queue):  \n​\n    return queue.front > queue.rear  // Return true if front pointer is greater than rear pointer, indicating an empty queue  \n​\n```  \n​\n  \n​\nIsEmpty operation checks if the queue is empty by comparing the front and rear pointers. It's a constant time operation as it only requires a single comparison.  \n​\n  \n​\n## Problems\n  \n​\nBelow are various problems from different platforms that test different aspects of Queue manipulations and understanding:  \n​\n  \n​\n### LeetCode\n  \n​\n- **[Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks)**: Implement a FIFO queue using only two stacks, ensuring all standard queue operations are supported.  \n​\n  \n​\n- **[Number of Visible People in a Queue](https://leetcode.com/problems/number-of-visible-people-in-a-queue)**: Determine the visibility of people in a queue based on their heights.  \n​\n  \n​\n- **[Design Circular Queue](https://leetcode.com/problems/design-circular-queue)**: Implement a circular queue, a linear data structure following FIFO principle with the last position connected back to the first to form a circle.  \n​\n  \n​\n- **[Orderly Queue](https://leetcode.com/problems/orderly-queue)**: You can choose one of the first k letters of a string and append it at the end of the string. Return the lexicographically smallest string you could have after applying this operation any number of times.  \n​\n  \n​\n- **[Number of Students Unable to Eat Lunch](https://leetcode.com/problems/number-of-students-unable-to-eat-lunch)**: Determine the number of students unable to eat lunch based on their sandwich preferences and the order of sandwiches in a stack.  \n​\n  \n​\n### HackerRank\n  \n​\n- **[Queue using Two Stacks](https://www.hackerrank.com/challenges/queue-using-two-stacks)**: Implement a queue using two stacks and process different types of queries.  \n​\n  \n​\n- **[Truck Tour](https://www.hackerrank.com/challenges/truck-tour)**: Determine the starting petrol pump from where the truck will be able to complete the circuit.  \n​\n  \n​\n- **[Queries with Fixed Length](https://www.hackerrank.com/challenges/queries-with-fixed-length)**: Process queries on an array, each query asking for the minimum value of the maximum values of all subarrays of a fixed length.  \n​\n  \n​\n- **[New Year Chaos](https://www.hackerrank.com/challenges/new-year-chaos)**: Determine the minimum number of bribes taken by the people in queue to get to their current state.  \n​\n  \n​\n- **[Ticket](https://www.hackerrank.com/challenges/tickets)**: Ensure orderly ticket distribution among people at a railway station while maintaining the order of the queue.  \n​\n  \n​\nThese problems cover a range of topics including queue implementation, processing queries, and managing elements in a queue.  \n​",
      "id": 4
    },
    {
      "name": "Hash Table",
      "content": "# Hash Table\n  \n​\n## Introduction\n  \n​\n  \n​\nA Hash Table is a data structure that stores key-value pairs. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found. It's like a dictionary where you can look up values based on their keys.  \n​\n  \n​\n## Use Cases\n  \n​\n- Hash Tables are used when there is a need to store and retrieve elements in a way that provides fast lookups, insertions, and deletions.  \n​\n- They are used in various applications such as databases, caches, sets, etc.  \n​\n- They might not be suitable for ordered data or when the data set is small enough that the overhead of hashing is not justified.  \n​\n  \n​\n## Operations\n  \n​\n- **Insert:** *O(1)* - Inserts a key-value pair into the hash table.  \n​\n- **Delete:** *O(1)* - Deletes a key-value pair from the hash table.  \n​\n- **Search:** *O(1)* - Searches for a key in the hash table and retrieves the value.  \n​\n- **Update:** *O(1)* - Updates the value associated with a key.  \n​\n  \n​\n## Implementation\n  \n​\n### Insert: *O(1)*\n  \n​\n```plaintext  \n​\nfunction insert(hashTable, key, value):  \n​\n    index = hashFunction(key)  // Compute the index using the hash function  \n​\n    if hashTable[index] is null:  \n​\n        hashTable[index] = new LinkedList()  // Create a new linked list if the slot is empty  \n​\n    hashTable[index].add((key, value))  // Add the key-value pair to the linked list  \n​\n```  \n​\n  \n​\nInsert operation computes the index using the hash function on the key, checks if the slot is empty, and if so, creates a new linked list. It then adds the key-value pair to the linked list. This is generally an O(1) operation, but can degrade to O(n) if many elements hash to the same index.  \n​\n  \n​\n### Delete: *O(1)*\n  \n​\n```plaintext  \n​\nfunction delete(hashTable, key):  \n​\n    index = hashFunction(key)  // Compute the index using the hash function  \n​\n    if hashTable[index] is not null:  \n​\n        hashTable[index].remove(key)  // Remove the key-value pair from the linked list  \n​\n```  \n​\n  \n​\nDelete operation computes the index using the hash function on the key, and if the slot is not empty, removes the key-value pair from the linked list. This is generally an O(1) operation, but can degrade to O(n) if many elements hash to the same index.  \n​\n  \n​\n### Search: *O(1)*\n  \n​\n```plaintext  \n​\nfunction search(hashTable, key):  \n​\n    index = hashFunction(key)  // Compute the index using the hash function  \n​\n    if hashTable[index] is not null:  \n​\n        return hashTable[index].search(key)  // Search for the key in the linked list and return the value  \n​\n    return null  // Key not found  \n​\n```  \n​\n  \n​\nSearch operation computes the index using the hash function on the key, and if the slot is not empty, searches for the key in the linked list and returns the value. This is generally an O(1) operation, but can degrade to O(n) if many elements hash to the same index.  \n​\n  \n​\n### Update: *O(1)*\n  \n​\n```plaintext  \n​\nfunction update(hashTable, key, newValue):  \n​\n    index = hashFunction(key)  // Compute the index using the hash function  \n​\n    if hashTable[index] is not null:  \n​\n        hashTable[index].update(key, newValue)  // Update the value associated with the key  \n​\n```  \n​\n  \n​\nUpdate operation computes the index using the hash function on the key, and if the slot is not empty, updates the value associated with the key in the linked list. This is generally an O(1) operation, but can degrade to O(n) if many elements hash to the same index.  \n​\n  \n​\n## Problems\n  \n​\nBelow are various problems from different platforms that test different aspects of Hash Table manipulations and understanding:  \n​\n  \n​\n### LeetCode\n  \n​\n- **[Design HashMap](https://leetcode.com/problems/design-hashmap)**: Implement a HashMap without using any built-in hash table libraries. The problem requires designing a `MyHashMap` class with methods to insert a (key, value) pair, get the value for a given key, and remove a key.  \n​\n  \n​\n- **[Design HashSet](https://leetcode.com/problems/design-hashset)**: Similar to the above problem, but now you need to design a HashSet without using any built-in hash table libraries. Implement a `MyHashSet` class with methods to add a key, check if a key exists, and remove a key.  \n​\n  \n​\n- **[Two Sum](https://leetcode.com/problems/two-sum)**: Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to the target. This problem is commonly solved using a hash table to store the indices of the numbers as they are processed.  \n​\n  \n​\n### HackerRank\n  \n​\n- **[Hash Tables: Ransom Note](https://www.hackerrank.com/challenges/ctci-ransom-note)**: This problem involves checking if it's possible to construct a ransom note by cutting out words from a magazine. It tests the basic understanding and implementation of hash tables.  \n​\n  \n​\n- **[Hash Tables: Ice Cream Parlor](https://www.hackerrank.com/challenges/ctci-ice-cream-parlor)**: Given the money pooled by Sunny and Johnny and the cost of each flavor, the task is to help them choose two distinct flavors such that they spend their entire pool of money. This problem can be solved efficiently using a hash table.  \n​\n  \n​\nThese problems cover a range of topics including the design and implementation of hash tables, as well as applying hash tables to solve common coding problems.  \n​",
      "id": 5
    }
  ]
}
